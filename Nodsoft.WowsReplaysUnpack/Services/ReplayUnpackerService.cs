using Nodsoft.WowsReplaysUnpack.Core;
using Nodsoft.WowsReplaysUnpack.Core.Abstractions;
using Nodsoft.WowsReplaysUnpack.Core.Exceptions;
using Nodsoft.WowsReplaysUnpack.Core.Extensions;
using Nodsoft.WowsReplaysUnpack.Core.Json;
using Nodsoft.WowsReplaysUnpack.Core.Models;
using Nodsoft.WowsReplaysUnpack.Core.Network.Packets;
using System.Diagnostics;
using System.IO.Compression;
using System.Text;
using System.Text.Json;

namespace Nodsoft.WowsReplaysUnpack.Services;

/// <summary>
/// Provides a controllable service for unpacking World of Warships replays.
/// </summary>
/// <typeparam name="TReplay"></typeparam>
public sealed class ReplayUnpackerService<TReplay> : ReplayUnpackerService, IReplayUnpackerService<TReplay>
	where TReplay : UnpackedReplay
{
	private readonly JsonSerializerOptions _jsonSerializerOptions = new() { PropertyNameCaseInsensitive = true };
	private readonly IReplayDataParser _replayDataParser;
	private readonly IReplayController<TReplay> _replayController;
	private const int _semephoreTimeOut = 2000;

	public ReplayUnpackerService(IReplayDataParser replayDataParser, IReplayController<TReplay> replayController)
	{
		_jsonSerializerOptions.Converters.Add(new ReplayDateTimeJsonConverter());
		_replayDataParser = replayDataParser;
		_replayController = replayController;
	}

	/// <inheritdoc />
	public TReplay Unpack(byte[] data, ReplayUnpackerOptions? options = null)
	{
		// Stream is disposed in Unpack method
		MemoryStream memoryStream = new(data);

		return Unpack(memoryStream, options);
	}

	/// <inheritdoc />
	public TReplay Unpack(Stream stream, ReplayUnpackerOptions? options = null)
	{
		/*
		# Header
		Every replay starts off with an 8 byte header, consisting of the following values:

		magic number - An unsigned 32 bit integer (4 bytes)
		block count - An unsigned 32 bit integer (4 bytes)
		The block count is an indication of how many data blocks (excluding the real replay data) are stored inside the replay. 
		For replays generated by a World of Tanks version before 0.8.1, the presence of 2 blocks means the replay is considered "complete",
		meaning it has the match start information, as well as a match result. 
		Replays generated by 0.8.1 and later versions are guaranteed to be complete if there are 2 or more blocks present.

		# Blocks
		Every data block starts with an unsigned 32 bit integer that holds the length of the data for the given block. 
		The first block consists of a JSON encoded structure. 
		In versions before 0.8.1, the second block is also a JSON encoded structure.

		# Reading
		Open the replay file
		Seek to offset 4 in the replay file (skipping the magic number)
		Read 4 bytes, and interpret these as an unsigned 32 bit integer, let this be "block count"
		For every block take the following action:
		Read 4 bytes, and interpret these as an unsigned 32 bit integer, let this be "data length"
		Read "data length" bytes
		Once all blocks have been read, the remainder of the data in the file is the compressed and encrypted replay data

		See http://wiki.vbaddict.net/pages/File_Replays for more details.
		*/
		options ??= new();
		Semaphore.Wait(_semephoreTimeOut);
		BinaryReader binaryReader = new(stream);

		byte[] signature = binaryReader.ReadBytes(4);
		int jsonBlockCount = binaryReader.ReadInt32();

		Semaphore.Release();
		// Verify replay signature
		if (!signature.SequenceEqual(ReplaySignature))
		{
			throw new InvalidReplayException("Invalid replay signature");
		}

		// The first block is the arena info
		// Read it and create the unpacked replay model
		ArenaInfo arenaInfo = ReadJsonBlock<ArenaInfo>(binaryReader);
		TReplay replay = _replayController.CreateUnpackedReplay(arenaInfo);
		Semaphore.Wait(_semephoreTimeOut);
		ReadExtraJsonBlocks(replay, binaryReader, jsonBlockCount);

		MemoryStream decryptedStream = new();
		Decrypt(binaryReader, decryptedStream);

		Semaphore.Release();
		// Initial stream and reader not used anymore
		binaryReader.Dispose();

		using MemoryStream replayDataStream = new();
		Decompress(decryptedStream, replayDataStream);

		// Decrypted stream not used anymore
		decryptedStream.Dispose();

		Version gameclientVersion = Version.Parse(arenaInfo.ClientVersionFromExe.Replace(',', '.'));
		Semaphore.Wait(_semephoreTimeOut);
		foreach (NetworkPacketBase networkPacket in _replayDataParser.ParseNetworkPackets(replayDataStream, options, gameclientVersion))
		{
			_replayController.HandleNetworkPacket(networkPacket, options);
		}
		Semaphore.Release();
		return replay;
	}

	private void ReadExtraJsonBlocks(UnpackedReplay replay, BinaryReader binaryReader, int jsonBlockCount)
	{
		if (jsonBlockCount <= 1)
		{
			return;
		}

		for (int i = 0; i < jsonBlockCount - 1; i++)
		{
			if (ReadJsonBlock<JsonElement?>(binaryReader) is { } jsonElement)
			{
				replay.ExtraJsonData.Add(jsonElement);
			}
				
		}
	}

	private T ReadJsonBlock<T>(BinaryReader binaryReader)
	{
		int blockSize = binaryReader.ReadInt32();
		Span<byte> jsonData = binaryReader.ReadBytes(blockSize);
		
		// If empty and T is nullable, return null
		if (jsonData.Length is 0 && typeof(T).IsGenericType && typeof(T).GetGenericTypeDefinition() == typeof(Nullable<>))
		{
			return default!;
		}
		
		Utf8JsonReader jsonReader = new(jsonData);

		// Debug string
		string message = Encoding.UTF8.GetString(jsonData);
		Debug.WriteLine(message);
		
		return JsonSerializer.Deserialize<T>(ref jsonReader, _jsonSerializerOptions) ?? throw new InvalidReplayException();
	}

	/// <summary>
	/// Replay Data is encrypted in 8 byte sized blocks
	/// These blocks were xor'd before encryption
	/// Here we reverse this process
	/// 1. Read the data in 8 byte chunks
	/// 2. Decrypt the chunk
	/// 3. Read the chunk as 8 byte number (long)
	/// 4. Bitwise xor with previous chunk value
	/// 5. Convert back to bytes
	/// </summary>
	/// <returns>Decrypted data</returns>
	private static void Decrypt(BinaryReader binaryReader, Stream targetStream)
	{
		long previousChunkValue = 0;

		using BinaryWriter binaryWriter = new(targetStream, Encoding.UTF8, true);
		// Ignore first chunk
		_ = binaryReader.ReadBytes(8);

		foreach (byte[] chunk in binaryReader.Chunkify())
		{
			try
			{
				long currentChunkValue = BitConverter.ToInt64(Blowfish.Decrypt_ECB(chunk));

				if (previousChunkValue is not 0)
				{
					currentChunkValue ^= previousChunkValue;
				}

				previousChunkValue = currentChunkValue;
				binaryWriter.Write(currentChunkValue);
			}
			catch (ArgumentOutOfRangeException) { }
		}
	}

	private static void Decompress(MemoryStream compressedStream, MemoryStream decompressedStream)
	{
		// DeflateStream doesn't strip the header so we strip it manually.
		compressedStream.Seek(2, SeekOrigin.Begin);
		using DeflateStream deflateStream = new(compressedStream, CompressionMode.Decompress);
		deflateStream.CopyTo(decompressedStream);
		decompressedStream.Seek(0, SeekOrigin.Begin);
	}
}

/// <summary>
/// Internal class used to house common methods and properties used
/// across all instances of the <see cref="ReplayUnpackerService{TController}"/> class.
/// </summary>
public class ReplayUnpackerService
{
	private static readonly byte[] BlowfishKey = "\x29\xB7\xC9\x09\x38\x3F\x84\x88\xFA\x98\xEC\x4E\x13\x19\x79\xFB".Select(Convert.ToByte).ToArray();
	protected static readonly byte[] ReplaySignature = "\x12\x32\x34\x11"u8.ToArray();
	protected static readonly Blowfish Blowfish = new(BlowfishKey);
	protected static readonly SemaphoreSlim Semaphore = new(1);

	private protected ReplayUnpackerService() { }
}