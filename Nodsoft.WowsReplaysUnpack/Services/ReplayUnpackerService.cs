using Nodsoft.WowsReplaysUnpack.Controllers;
using Nodsoft.WowsReplaysUnpack.Core;
using Nodsoft.WowsReplaysUnpack.Core.Exceptions;
using Nodsoft.WowsReplaysUnpack.Core.Extensions;
using Nodsoft.WowsReplaysUnpack.Core.Json;
using Nodsoft.WowsReplaysUnpack.Core.Models;
using Nodsoft.WowsReplaysUnpack.Core.Network.Packets;
using System.IO.Compression;
using System.Text;
using System.Text.Json;
using System.Threading;

namespace Nodsoft.WowsReplaysUnpack.Services;

/// <summary>
/// Provides a controllable service for unpacking World of Warships replays.
/// </summary>
/// <typeparam name="TController">Type of the controller, responsible for data extraction.</typeparam>
public sealed class ReplayUnpackerService<TController> : ReplayUnpackerService, IReplayUnpackerService
	where TController : IReplayController
{
	private readonly JsonSerializerOptions _jsonSerializerOptions = new() { PropertyNameCaseInsensitive = true };
	private readonly IReplayDataParser _replayDataParser;
	private readonly IReplayController _replayController;
	private static readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1);

	public ReplayUnpackerService(IReplayDataParser replayDataParser, TController replayController)
	{
		_jsonSerializerOptions.Converters.Add(new ReplayDateTimeJsonConverter());
		_replayDataParser = replayDataParser;
		_replayController = replayController;
	}

	/// <inheritdoc />
	public UnpackedReplay Unpack(byte[] data, ReplayUnpackerOptions? options = null)
	{
		// Stream is disposed in Unpack method
		MemoryStream memoryStream = new(data);

		return Unpack(memoryStream, options);
	}

	/// <inheritdoc />
	public UnpackedReplay Unpack(Stream stream, ReplayUnpackerOptions? options = null)
	{
		/*
		# Header
		Every replay starts off with an 8 byte header, consisting of the following values:

		magic number - An unsigned 32 bit integer (4 bytes)
		block count - An unsigned 32 bit integer (4 bytes)
		The block count is an indication of how many data blocks (excluding the real replay data) are stored inside the replay. 
		For replays generated by a World of Tanks version before 0.8.1, the presence of 2 blocks means the replay is considered "complete",
		meaning it has the match start information, as well as a match result. 
		Replays generated by 0.8.1 and later versions are guaranteed to be complete if there are 2 or more blocks present.

		# Blocks
		Every data block starts with an unsigned 32 bit integer that holds the length of the data for the given block. 
		The first block consists of a JSON encoded structure. 
		In versions before 0.8.1, the second block is also a JSON encoded structure.

		# Reading
		Open the replay file
		Seek to offset 4 in the replay file (skipping the magic number)
		Read 4 bytes, and interpret these as an unsigned 32 bit integer, let this be "block count"
		For every block take the following action:
		Read 4 bytes, and interpret these as an unsigned 32 bit integer, let this be "data length"
		Read "data length" bytes
		Once all blocks have been read, the remainder of the data in the file is the compressed and encrypted replay data

		See http://wiki.vbaddict.net/pages/File_Replays for more details.
		*/
		options ??= new();
		_semaphore.Wait();
		BinaryReader binaryReader = new(stream);

		byte[] signature = binaryReader.ReadBytes(4);
		int jsonBlockCount = binaryReader.ReadInt32();

		_semaphore.Release();
		// Verify replay signature
		if (!signature.SequenceEqual(ReplaySignature))
		{
			throw new InvalidReplayException("Invalid replay signature");
		}

		// The first block is the arena info
		// Read it and create the unpacked replay model
		UnpackedReplay replay = _replayController.CreateUnpackedReplay(ReadJsonBlock<ArenaInfo>(binaryReader));
		_semaphore.Wait();
		ReadExtraJsonBlocks(replay, binaryReader, jsonBlockCount);

		MemoryStream decryptedStream = new();
		Decrypt(binaryReader, decryptedStream);

		_semaphore.Release();
		// Initial stream and reader not used anymore
		binaryReader.Dispose();

		using MemoryStream replayDataStream = new();
		Decompress(decryptedStream, replayDataStream);

		// Decrypted stream not used anymore
		decryptedStream.Dispose();


		_semaphore.Wait();
		foreach (NetworkPacketBase networkPacket in _replayDataParser.ParseNetworkPackets(replayDataStream, options))
		{
			_replayController.HandleNetworkPacket(networkPacket, options);
		}
		_semaphore.Release();
		return replay;
	}

	private void ReadExtraJsonBlocks(UnpackedReplay replay, BinaryReader binaryReader, int jsonBlockCount)
	{
		if (jsonBlockCount > 1)
		{
			for (int i = 0; i < jsonBlockCount - 1; i++)
			{
				replay.ExtraJsonData.Add(ReadJsonBlock<JsonElement>(binaryReader));
			}
		}
	}

	private T ReadJsonBlock<T>(BinaryReader binaryReader)
	{
		int blockSize = binaryReader.ReadInt32();
		byte[] jsonData = binaryReader.ReadBytes(blockSize);
		Utf8JsonReader jsonReader = new(jsonData);

		return JsonSerializer.Deserialize<T>(ref jsonReader, _jsonSerializerOptions) ?? throw new InvalidReplayException();
	}

	/// <summary>
	/// Replay Data is encrypted in 8 byte sized blocks
	/// These blocks were xor'd before encryption
	/// Here we reverse this process
	/// 1. Read the data in 8 byte chunks
	/// 2. Decrypt the chunk
	/// 3. Read the chunk as 8 byte number (long)
	/// 4. Bitwise xor with previous chunk value
	/// 5. Convert back to bytes
	/// </summary>
	/// <returns>Decrypted data</returns>
	private static void Decrypt(BinaryReader binaryReader, Stream targetStream)
	{
		long previousChunkValue = 0;

		using BinaryWriter binaryWriter = new(targetStream, Encoding.UTF8, true);
		// Ignore first chunk
		_ = binaryReader.ReadBytes(8);

		foreach (byte[] chunk in binaryReader.Chunkify())
		{
			try
			{
				long currentChunkValue = BitConverter.ToInt64(Blowfish.Decrypt_ECB(chunk));

				if (previousChunkValue is not 0)
				{
					currentChunkValue ^= previousChunkValue;
				}

				previousChunkValue = currentChunkValue;
				binaryWriter.Write(currentChunkValue);
			}
			catch (ArgumentOutOfRangeException) { }
		}
	}

	private static void Decompress(Stream compressedStream, Stream decompressedStream)
	{
		// DeflateStream doesn't strip the header so we strip it manually.
		compressedStream.Seek(2, SeekOrigin.Begin);
		using DeflateStream deflateStream = new(compressedStream, CompressionMode.Decompress);
		deflateStream.CopyTo(decompressedStream);
		decompressedStream.Seek(0, SeekOrigin.Begin);
	}
}

/// <summary>
/// Internal class used to house common methods and properties used
/// across all instances of the <see cref="ReplayUnpackerService{TController}"/> class.
/// </summary>
public class ReplayUnpackerService
{
	private static readonly byte[] BlowfishKey = "\x29\xB7\xC9\x09\x38\x3F\x84\x88\xFA\x98\xEC\x4E\x13\x19\x79\xFB".Select(Convert.ToByte).ToArray();
	protected static readonly byte[] ReplaySignature = Encoding.UTF8.GetBytes("\x12\x32\x34\x11");
	protected static readonly Blowfish Blowfish = new(BlowfishKey);

	private protected ReplayUnpackerService() { }
}