using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Nodsoft.WowsReplaysUnpack.Core;
using Nodsoft.WowsReplaysUnpack.Core.Extensions;
using Nodsoft.WowsReplaysUnpack.Core.Json;
using Nodsoft.WowsReplaysUnpack.Core.Network.Packets;
using Nodsoft.WowsReplaysUnpack.Infrastructure.Exceptions;
using Nodsoft.WowsReplaysUnpack.Models;
using Nodsoft.WowsReplaysUnpack.Models.Replay;
using System;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Text.Json;

namespace Nodsoft.WowsReplaysUnpack.Services;


public class ReplayUnpackerService
{
	private static readonly byte[] BlowfishKey = "\x29\xB7\xC9\x09\x38\x3F\x84\x88\xFA\x98\xEC\x4E\x13\x19\x79\xFB"
		  .Select(Convert.ToByte).ToArray();
	private static readonly Blowfish Blowfish = new(BlowfishKey);
	private static readonly byte[] ReplaySignature = Encoding.UTF8.GetBytes("\x12\x32\x34\x11");

	private readonly JsonSerializerOptions _jsonSerializerOptions = new() { PropertyNameCaseInsensitive = true };
	private readonly IServiceProvider _serviceProvider;
	private readonly ILogger<ReplayUnpackerService> _logger;

	public ReplayUnpackerService(IServiceProvider serviceProvider, ILogger<ReplayUnpackerService> logger)
	{
		_jsonSerializerOptions.Converters.Add(new DateTimeJsonConverter());
		_serviceProvider = serviceProvider;
		_logger = logger;
	}


	///// <summary>
	///// Unpacks a replay from a stream.
	///// Uses the default <see cref="ReplayParserProvider.Instance">ReplayParserProvider instance</see>.
	///// </summary>
	///// <param name="stream">The stream containing the replay file content.</param>
	///// <returns>The unpacked replay, wrapped in a <see cref="ReplayRaw"/> instance.</returns>
	///// <exception cref="InvalidReplayException">Occurs if the replay file is not valid.</exception>
	//public ReplayRaw UnpackReplay(Stream stream)
	//	=> UnpackReplay(stream, ReplayParserProvider.Instance);

	///// <summary>
	///// Unpacks a replay from a stream.
	///// Uses a custom <see cref="IReplayParserProvider"/> implementation.
	///// </summary>
	///// <param name="stream">The stream containing the replay file content.</param>
	///// <param name="parserProvider">The <see cref="IReplayParserProvider"/> implementation to use to retrieve the necessary <see cref="IReplayParser"/>.</param>
	///// <returns>The unpacked replay, wrapped in a <see cref="ReplayRaw"/> instance.</returns>
	///// <exception cref="InvalidReplayException">Occurs if the replay file is not valid.</exception>
	//public ReplayRaw UnpackReplay(Stream stream, IReplayParserProvider parserProvider)
	//{
	//	byte[] bReplaySignature = new byte[4];
	//	byte[] bReplayBlockCount = new byte[4];
	//	byte[] bReplayBlockSize = new byte[4];

	//	stream.Read(bReplaySignature, 0, 4);
	//	stream.Read(bReplayBlockCount, 0, 4);
	//	stream.Read(bReplayBlockSize, 0, 4);

	//	// Verify replay signature
	//	if (!bReplaySignature.SequenceEqual(ReplaySignature))
	//	{
	//		throw new InvalidReplayException("Invalid replay signature.");
	//	}

	//	int jsonDataSize = BitConverter.ToInt32(bReplayBlockSize, 0);
	//	byte[] bReplayJsonData = new byte[jsonDataSize];
	//	stream.Read(bReplayJsonData, 0, jsonDataSize);

	//	JsonSerializerOptions options = new() { PropertyNameCaseInsensitive = true };
	//	options.Converters.Add(new DateTimeJsonConverter());
	//	Utf8JsonReader reader = new(bReplayJsonData);
	//	ReplayMetadata metadata = new()
	//	{
	//		//ArenaInfo = JsonSerializer.Deserialize<ArenaInfo>(ref reader, options) ?? throw new InvalidReplayException(),
	//		BReplaySignature = bReplaySignature,
	//		BReplayBlockCount = bReplayBlockCount,
	//		BReplayBlockSize = bReplayBlockSize,
	//	};

	//	Version replayVersion = Version.Parse(string.Join('.', metadata.ArenaInfo.ClientVersionFromExe.Split(',')[..3]));
	//	IReplayParser replayParser = parserProvider.FromReplayVersion(replayVersion);

	//	using MemoryStream memStream = new();
	//	stream.CopyTo(memStream);
	//	ReplayRaw replay = replayParser.ParseReplay(memStream, metadata);

	//	return replay;
	//}

	public UnpackedReplay Unpack(byte[] data, ReplayUnpackerOptions? options = null)
	{
		using MemoryStream memoryStream = new MemoryStream(data);
		return Unpack(memoryStream, options);
	}

	public UnpackedReplay Unpack(Stream stream, ReplayUnpackerOptions? options = null)
	{
		/*
		# Header
		Every replay starts off with an 8 byte header, consisting of the following values:

		magic number - An unsigned 32 bit integer (4 bytes)
		block count - An unsigned 32 bit integer (4 bytes)
		The block count is an indication of how many data blocks (excluding the real replay data) are stored inside the replay. 
		For replays generated by a World of Tanks version before 0.8.1, the presence of 2 blocks means the replay is considered "complete",
		meaning it has the match start information, as well as a match result. 
		Replays generated by 0.8.1 and later versions are guaranteed to be complete if there are 2 or more blocks present.

		# Blocks
		Every data block starts with an unsigned 32 bit integer that holds the length of the data for the given block. 
		The first block consists of a JSON encoded structure. 
		In versions before 0.8.1, the second block is also a JSON encoded structure.

		# Reading
		Open the replay file
		Seek to offset 4 in the replay file (skipping the magic number)
		Read 4 bytes, and interpret these as an unsigned 32 bit integer, let this be "block count"
		For every block take the following action:
		Read 4 bytes, and interpret these as an unsigned 32 bit integer, let this be "data length"
		Read "data length" bytes
		Once all blocks have been read, the remainder of the data in the file is the compressed and encrypted replay data

		See http://wiki.vbaddict.net/pages/File_Replays for more details;
		*/
		options ??= new();

		if (options.Mode is ReplayUnpackerMode.IgnoreCVECheck)
			_logger.LogWarning("IgnoreCVECheck mode is active");

		UnpackedReplay replay;
		BinaryReader binaryReader = new(stream);

		byte[] signature = binaryReader.ReadBytes(4);
		int jsonBlockCount = binaryReader.ReadInt32();

		// Verify replay signature
		if (!signature.SequenceEqual(ReplaySignature))
		{
			throw new InvalidReplayException("Invalid replay signature");
		}

		// The first block is the arena info
		// Read it and create the unpack replay info
		replay = new(ReadJsonBlock<ArenaInfo>(binaryReader));
		ReadExtraJsonBlocks(replay, binaryReader, jsonBlockCount);

		MemoryStream decryptedStream = new();
		Decrypt(binaryReader, decryptedStream);

		// Initial stream and reader not used anymore
		binaryReader.Close();
		binaryReader.Dispose();

		using MemoryStream replayDataStream = new();
		Decompress(decryptedStream, replayDataStream);

		// Decrypted stream not used anymore
		decryptedStream.Close();
		decryptedStream.Dispose();

		using IServiceScope parserScope = _serviceProvider.CreateScope();
		using IReplayDataParser replayDataParser = parserScope.ServiceProvider.GetRequiredService<IReplayDataParser>();
		IReplayController replayController = parserScope.ServiceProvider.GetRequiredService<IReplayController>();
		foreach (INetworkPacket networkPacket in replayDataParser.ParseNetworkPackets(replayDataStream, options))
			replayController.HandleNetworkPacket(replay, networkPacket);

		return replay;
	}

	private void ReadExtraJsonBlocks(UnpackedReplay replay, BinaryReader binaryReader, int jsonBlockCount)
	{
		if (jsonBlockCount > 1)
		{
			foreach (var _ in Enumerable.Range(0, jsonBlockCount - 1))
				replay.ExtraJsonData.Add(ReadJsonBlock<JsonElement>(binaryReader));
		}
	}

	private T ReadJsonBlock<T>(BinaryReader binaryReader)
	{
		int blockSize = binaryReader.ReadInt32();
		byte[] jsonData = binaryReader.ReadBytes(blockSize);
		Utf8JsonReader jsonReader = new(jsonData);
		return JsonSerializer.Deserialize<T>(ref jsonReader, _jsonSerializerOptions) ?? throw new InvalidReplayException();
	}

	/// <summary>
	/// Replay Data is encrypted in 8 byte sized blocks
	/// These blocks were xor'd before encryption
	/// Here we reverse this process
	/// 1. Read the data in 8 byte chunks
	/// 2. Decrypt the chunk
	/// 3. Read the chunk as 8 byte number (long)
	/// 4. Bitwise xor with previous chunk value
	/// 5. Convert back to bytes
	/// </summary>
	/// <param name="binaryReader"></param>
	/// <returns>Decrypted data</returns>
	private void Decrypt(BinaryReader binaryReader, MemoryStream targetStream)
	{
		long previousChunkValue = 0;

		using BinaryWriter binaryWriter = new(targetStream, Encoding.UTF8, true);
		// Ignore first chunk
		_ = binaryReader.ReadBytes(8);

		foreach (byte[] chunk in binaryReader.Chunkify())
		{
			try
			{
				long currentChunkValue = BitConverter.ToInt64(Blowfish.Decrypt_ECB(chunk));

				if (previousChunkValue is not 0)
				{
					currentChunkValue ^= previousChunkValue;
				}

				previousChunkValue = currentChunkValue;
				binaryWriter.Write(currentChunkValue);
			}
			catch (ArgumentOutOfRangeException) { }
		}
	}

	private void Decompress(MemoryStream compressedStream, MemoryStream decompressedStream)
	{
		// DeflateStream doesn't strip the header so we strip it manually.
		compressedStream.Seek(2, SeekOrigin.Begin);
		using DeflateStream deflateStream = new(compressedStream, CompressionMode.Decompress);
		deflateStream.CopyTo(decompressedStream);
		decompressedStream.Seek(0, SeekOrigin.Begin);
	}
}
